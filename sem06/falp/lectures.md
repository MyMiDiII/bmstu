# Лекция 4

> 09.03.2022

1. Стуктуроразрушающие
2. Неструктуроразрушающие (делают копии, работают медленнее)

Все работают только с верхним уровнем списка.

При сравнении используется eql, которая не умеет сравнивать списки.

Для работы с множествами есть стандартные функции: объединение, пересечения.

member --- позволяет проверить присутствие элемента в списке

`(member el lst)`

`(member '(a b) '(c (a b) d))`

Если el --- атом, то все найдется.

Если подадим список, то система не обнаружит этот список, но можно повлиять на
работу функции member.

При создании функции используется система ключевых параметров, они могут
быть использованы. Реализация функции с переменным числом параматров
создается с помощью ключевых параметров. Надо знать имена.

Ключевой параметр test.

`(member '(a b) '(c (a b) d) :test #'equal)`

На выходе:

`((a b) d)`

Функционал --- принимает в качестве аргументов функции, или возвращает функцию.

1. Применяющие (apply, funcall)
2. Отображающие (mapcar, maplist)

mapcar принимает первым параметром имя функции или lambda-опеделение. Применяет
функцию к элементам, проходя только по верхнему уровню.

Может применять и многоаргументную функцию:

`(mapcar #'fun lst1 lst2 ... lstk)`

Если меньше mapcar не работает, если больше, то последние игнорирует.

Выбирает головы списков, применяет, потом головы хвостов, применяет и т.~д.

Получает несколько результатов, возвращет список результатов.

maplist должна уметь работать с список, с хвостом списка, который список...

Может быть одно и многоаргументной.

`(maplist #'fun lst1 lst2 ... lstk)`

Списки целиком, потом хвосты, потом хвосты хвостой и т.~д.

Заканчивает работу, когда заканчивается самый короткий.

mapcar и maplist имеют аналоги, которые не создают копий, используют
структуро-разрушающую функцию nconc:

`mapcan`
`mapcon`

`(find-if #'pred lst)`

Функция find-if проходит по верхнему уровню, возвр певрый элемент списка,
удовлетворяющий данному предикату.

`(find-if #'odd (2 4 7 5))` -> 7

Не удовлетворяющий:

`(find-if-not #'pred lst` -> 2
`(find-if-not #'add (2 4 7 5))` -> 2

Удаление по условию:

`(remove-if #'pred lst)`
`(remove-if-not #'pred lst)`

Применение функции касадно.

`(reduce #'fun lst)`

Для первых двух, потом для результату и след элементу, к рез-ту и элементу и
тд.

`(every #'predicate lst')`

возращает T, если все удовлетворяют предикату.

`(some #'predicate lst)`

Примеры:

```
(defun consist-of (lst)
    (if (member (car lst) (cdr lst)) 1 0))
```

```
(defun all-last-element (lst)
    (if (eql (consist-of lst) 0) (list (car lst)) ())
```

```
(defun collection-to-set (lst)
    (mapcon #'all-last-element lst))
```

```
(collection-to-set '(i t i g t k s i f k)')
```

Результат: `(g t s i f k)`

```
(defun decart (lstX lstY)
    (mapcan #'(lambda (x)
                    (mapcar #'(lambda (y)
                                    (list x y)) lstY))
                                                lstX))
```

`(decart '(a b) '(1 2))` -> ((a 1) (a 2) (b 1) (b 2))

## Рекурсия

Рекурсия --- ссылка на описываемый объект внутри описания этого объекта.

Закончить надо, когда закончится список. Не единственная причина выхода из
рекурсии.

Надо менять аргументы.

Думать, как первый раз запустить.

Классификация рекурсий:

1. Простая рекурсия: рекурсивный вызов встречается в теле функции один раз.
2. Рекурсия первого порядка: рекурсивный вызов несколько раз.
3. Взаимная рекурсия: несколько рекурсивных функций, которые вызывают друг
   друга.

Проверить не нужно ли выйти из рекурсии, а потом вызов.

Первые ветки --- выход.

Собирать все на выходе --- неэффективно.

Надо не оставлять отложенных вычислений.

Если все сделать заранее, то все будет классно :).

В стеке ничего не надо хранить, он не переполнится --> хвостовая рекурсия.

Надо, чтобы не оставалось недоделаннной работы.

Примеры:

```
(defun my_member (el lst)
    (cond ((null lst) Nil)
          ((equal el (car lst)) T)
          (T (my_member el (cdr lst)))))

(my_member 'a '(a b c)) ; -> T

(my_member Nil ()) ; -> Nil (не совсем правильно,
                   ; можно переставить два условия выхода)
```

Неэффективный способ:

```
(defun my-reverse (lst)
    (cond ((null lst) lst)
          (T (append (my-reverse (cdr lst) (cons (car lst) lst))))))
```

Нехвостовая в хвостовую, используя доп параметр.

Ещё способ:

```
(defun my-reverse1 (lst)
    (move-t lst ()))

(defun move-to (lst result)
    (cond ((null lst) result)
          (T (move-to (cdr lst) (cons (car lst) result)))))
```

# Лекция 5

> 16.03.2022

5-ая --- любые стандартные функции (допускается неэффективность).

6-7 --- улучшение.

Рекурсивная функция --- функция, вызывающая сама себя.

Хвостовая рекусия может останавливать работу:

1. по одному условию;
2. по нескольким условиям.

Хорошая рекурсия --- это когда формируем результат на входе, не остается
недовычисленных результатов.

```lisp
(defun fun (x)
    (cond (end_test end_value)
          (t (fun chanched_x))))
```

Первый атом:

```
(defun first_a (lst)
    (cond ((atom lst) lst)
          (t (first_a (car lst))))
```

Первое нечетное:

```
(defun find_first_odd (lst)
    (cond ((null lst) nil)
          ((odd (find_a lst)) (first_a lst))
          (t (find_first_odd (cdr lst)))))
```

```
(defun my_nth (lst n)
    (cond ((null lst) nil)
          ((= n 0) (car lst))
          (t (my_nth (cdr lst) (- n 1)))))
```

Дополняемая рекурсия (есть доп функция, которая используется доп метод
обработки рекурсивного вызова).

```
(defun fun (x)
    (cond (end_test end_value)
          (t (add_function add_value
                           (func changed_x)))))
```

```
(defun my_length (lst)
    (cond ((null lst) 0)
          (t (+ 1 (my_length (cdr lst))))))
```

Преобразование многоуровневого списка в одноуровневый:

```
(defun into-one-level (lst)
    (cond ((null lst) nil)
          ((atom lst) (cons lst))
          (t (append (into-one-level (car lst)
                      into-one-level (cdr lst))))))
```

Если в качестве дополнительной функции используется cons, то это
cons-дополняемая рекурсия.

```
(defun insert_help (x lst)
    (cond ((null lst) (list x))
          ((<= x (cdr lst)) (cons x lst))
          (t (cons (car lst) (insert_help x (cdr lst))))))
```

```
(defun sort_help (lst1 lst2)
    (cond ((null lst1) lst2)
          (t (sort_help (cdr lst) (insert_help (car lst1) lst2)))))
```

```
(defun sort_ins (lst)
    (sort_help lst ()))
```

# Лекция 7 

> 30.03.2022

## Prolog

Работает со знаниями, не с данными.

Мат логика:

* высказываения;
* операции (конъюнкция, дизъюнкция, отрицание);
* предикаты.

Логическое программирование:

* символьная обработка, не числовая;
* работа со знаниями.

Аксиома -- факт (то, что принимается как справедливое утверждение).

Теоремы -- это, в общем, знания.

Появилось в 70-е годы.

Программа на пролог -- база знаний, состоящая из фактов (аксиом) и правил.
(что-то про опрации).

Вопросы???

База данных сост из предложений, каждое из которых заканчивается точкой.
Начинается со слова clause (предложение)???

go -- цель

Терм -- либо константа, либо переменная, либо составное тело.

Надо синтаксически отличать переменные и константы:

`ab` -- символьный атом (константа???)
`Ab, _a` -- пременная

Использование переменных -- более высокий уровень абстракции.

Именованные переменные и анонимные.

Внешняя форма составного терма:

`f(t1, t2, ..., tn)`

f -- главный функтор (имя отношения);
t1, ..., tn -- термы.

Символьные атомы, как для объектов, так и для имен отношений.

`student(ivanov, mgtu).`

`student(ivanov).`

`student(X, mgtu).` -- в момент фиксации не имеет логического значения???
Задача системы "выполнить", определить истина или ложь.

1 и 2 -- разные знания.

Если в последнем точка, то система не знает, чему равно X.

Какой-то X может быть студентом.

Правило будет ли X студентом.

При формулировке X не имеет значения вообще.

Не содержат переменные -- основные, иначе -- неосновные.

`A := B1, B2, ..., Bk.`

`student(X, mgtu) := докум(X, att), выше(ball, 296)`

Особенный способ работы с переменными:

не задаем значение переменной, система сама подберет её значение, так, чтоб
выражение было истинно, это ее цель (подобрать такие значения, чтобы
ответ был "да").

Переменные нужны для передачи данных во времени и пространстве
(подпрограммы). 

# Лекция 8

> 06.04.2022

Именованные перменные служат для передачи значений во времени и пространстве.

Переменная будет конкретизирована каким-то значением, но оно может быть
ошибочно, система предполагает.

Потом система будет реконкретизировать переменные в процессе работы.

Синтактическая конструкция -- термы.

Анонимные переменные система не конкретизирует значениям. Вернуть значение через
них нельзя. Зачем они тогда нужны?

Алгоритм доказательства (алгоритм унификации) многократно запускается системой,
чтобы получить ответ на поставленный вопрос. Не доступен пользователю.

Переменные могут быть связаны кванторами: существования, общности, отрицания.

Уникальность переменных.

Мы формулируем знания обобщенно... 

Каждый факт и правил -- это предложение. Каждое предложение оканчивается точкой.

В файты и правила переменная входит с квантором всеобщности. Его не пишут.

В вопрос входит с квантором существования. Его тоже в таком случае не пишут.

В пределах какого текста переменная уникальна.

Именнованная -- в рамках одного предложения.

Анонимная переменная уникальна всегда.

Правило -- заголовок и тело.

Знания в заголовке (фиксация знания).

Заголовок -- в виде составного терма мы фиксируем знания о свойствах или
характиристиках объекта, либо объектами есть связь.

Составной терм состоит из главного функтора (имя отношения) и аргументов(те,
объекты, между которыми существует связь).

В теле -- условия истинности, зафиксированных также в виде составного терма.

Факт -- тоже в виде составного терма.

Факт -- частный случай правила.

Формулировки правил -- условная истина.

## Процедурные и декларативные особенности пролог.

Система что с чем должна сравнивать?

Вопрос с заголовком. Порядок установлен сверху вниз.

Система сравнивает по два (составных?) терма.

Главный функтор -- это знание про то или не про то ;)

Главные функторы должны совпадать, количество аргументов должно совпадать...

## Подстановки и примеры термов.

Неосновные? термы имеют заголовок и переменные.

```A(X_1, X_2, ..., X_n)```

Подстановкой наз мн-в пар вида {X_i = t_i}, X_i -- переменная, t_i -- терм, не
содержащий переменные (возможное значение переменной)

\theta={X_i}

Применение подстановки заключается замене каждого вхождения перменной X_i на
соотвествующее t_i.

Терм B явл примером терма А, если существует такая подстановка \theta, что
B = A \theta.

Терм C наз общим примером термов A и B, если сущ. такие подстановки \theta_1
и \theta_2, что C = A \theta_1 и C = B \theta_2.

A = plus(1, 2, Z)
    plus(X, Y, 3)

Сначала факты, потом факты и правила... (это в лабах)

Запятая -- операция конъюнкции.

`father(X, Y), father(Y, Z)`

Природа этих объектов. Эти знания про одни и те же объекты, про их природы.

Процедура -- совокупность правил, заголовки которых имеют одинаковый главный
функтор, одинаковым количеством аргументов, обозначающих объекты одной и той же
природы.

Процедура -- одно знание, которое может быть зафиксировано с исп нескольких
предложений.

Структура знания в разделе predicate.

Не связано с выделением памятью и понятием типа.

> Стек чей? Кто его создал?

> Вопрос, на который ты никогда не узнаешь ответ.

Когда работает алгоритм унификации он использует какую-то область памяти ...

Порядок:

* знаний в базе знаний
4

Для чего алгоритм унификации запускается -- для того, чтобы подобрать знания.

## Механизм логического вывода. Простейшие правила.

Правила вывода -- это утверждения о взаимосвязи между допущениями и
заключениями, которые с позиции исчисления предикатов верны всегда.

Четыре варианта:

* факты не содержат перменных, и вопрос тоже не содержит (основные) -- правила
  совпадения;
* факты основные, а вопрос неосновной (переменная с фактором существования) --
  обобщение факта;
* факты неосновные (всеобщность), а вопрос основной -- правило конкретизации;
* и факты и вопрос неосновные -- правило ??? (система должна построить общий пример
  терма вопроса, терма знания -- подобрать эту подстановку)

ДОказательство осуществляется в 2 шага: правило конкртизации и далее правило
обобщения.

Шаг автоматизации -- основной вычислительный шаг, с помощью которого происходит:

1) двунаправленная передача параметров процедурам;
2) неразрушающее присваивание (конкретизация);
3) проверка условий (два терма могут быть унифицированы успешно, то есть они
похожи).

T_1 и T_2

Если константы, то только в том случае, если они совпадают, они унифицируемые

Если T_1 -- неконкретизированная переменная, T_2 -- константа или составной
терм, несодержащий в качестве аргументы T_1, то унификация успешна, а T_1
конкретизируется значением T_2.

Если T_1 и T_2 -- некокретизированые переменные, то их унификация всегда
успешна, и два терма становятся сцепленными, то есть двумя именами (указателями)
одного и того же объекта, то есть двумя указателями на один и тот же объект.

Если у T_1 и T_2 одинаковые главные функторы, T_1 и T_2 ...???
успешно унифицируется каждая пара их соответсвующих компонентов.


# Лекция 9

> 13.04.2022

# Алгоритм унификации

Предназначен для того, чтобы подобрать знания, с помощью которых можно ответить
на поставленный вопрос.

Переменные в вопросе и в знании -- разные переменные.

Если удалось подобрать знание, то ещё не значит, что можно ответить "да", ещё
надо построить тело.

Алгоритм в процессе поиска ответа на вопрос запускается многократно.

Алгоритм унификации --- для системы процесс, след, происходит рапределение
ресурсов, выделяются области памяти, которые используются для разных целей,
поэтому это разные области памяти.

Алгоритм унификации:

* рабочее поле (область памяти);
* стек (для хранения равенств, возможность унификации которых проверяется);
* результирующая ячейка (динамическая область память, в которой накапливается
  подстановка (значение)).

Подобрано/не подобрано => использует флаг (неудача), 0 -- успех, 1 -- неудача.
Удается/не удается (принудительно унификация не проводится).

АУ предназначен для того, чтобы проверить удается ли унифицировать два терма.

```
T_1 = T2
начало
    занести T_1 = T_2
    положить неудача = 0
    пока стек не пуст
        считать  из стека в рабочее поле S=T
        a
        b
        c
        d
        e
        f
        очистить рабочее поле
    выйти цикла
```

Если S и T несовпадающие константы, то неудача = 1 и выход из цикла

Если S и T совпадающие константы, то следующий шаг цикла 

Если S -- переменная, а T -- терм, сод. S, то неудача = 1 и выход из цикла

Если S -- переменная, а T -- терм, не сод. S, то отыскать в стеке и
результирующей ячейке все вхождения S и заменить их на T, добавить в
результирующую ячейку S = T.

Если S и T -- термы, имеющие разные главные функторы или арность, то неудача = 1
и выход из цикла.

Если S и T -- термы с одинаковыми главные функторы и арность, то занести в стек
равенства:

```
S1 = T1,
S2 = T2,
...
Sk = Tk
```

S=F(S1,S2,...,Sk), T=F(T1, T2, ..., Tk) =>

Если в результате неудача = 1, то унификация невозможна, если неудача = 0, то
унификация успешна, а результирующая ячейка содержит подстановку -- эта
подстановка называется **наиболее общим унификатором**.

Терм S называется более общим, чем T, если терм T является примером S, а S не
является примером T.

Терм S называется наиболее общим термом термов T1 T2, если S такой общий пример,
который является более общим по отношению к любому другому их примеру.

Унификатором двух термов называется подстановка, которая будучи применена к
каждому терму даст одинаковый результат.

Наиболее общим унификатором двух термов называется унификатор, соответствующий
наиболее общему примеру двух термов.

Th

Если два терма унифицируемы, то существует единственный, с точностью до
переименования переменных, наиболее общий унификатор, а, значит, наиболее общий
пример.

Однократный запуск АУ помогает системе проверить подходит или не подходит данное
знание для дальнейшей работы?

Можем влиять только на порядок правил.

Цель -- цель для системы, что именно в данный момент она доказывает

# Общая схема согласования ...

Решение задачи с пом лог программы с задания вопроса G и завершается получением
одного из двух результатов:

1. успешного согласования вопроса и программы, а в качестве побочного эффекта
   получена подстановка, которая содержит значения переменных, при которых
   вопрос является примером программы или несколько таких примеров и решений;
2. неудача

Пошаговое преобразования исходного вопроса  

На каждом шаге имеется конъюнкция целей, выводимость которых необходимо
доказать.

Эта конъюнкция целей называется резольвентой. Система хранит её, динамически, в
стеке.

Успех достигается тогда, когда резольвента пуста.

Преобразование резольвенты выполняется с помощью операции, которая называется
редукцией.

Редукцией цели G с помощью программы P называется замена цели G телом того
правила из P, заголовок которого унифицируется с целью.

Резольвета преобразуется.

Новая резольвента образуется в два этапа.

1. в тек резольвенте выбирается одна из целей, и для нее выполняется редукция.
2. затем к полученной конъюнкции целей применяется подстановка, полученная как
   наибольший общий унификатор цели и заголовка, сопоставленного с ней правилом.

Если для редукции был подобран факт, то резольвента уменьшится на одну
цель.

# Лекция 4

> 09.03.2022

1. Стуктуроразрушающие
2. Неструктуроразрушающие (делают копии, работают медленнее)

Все работают только с верхним уровнем списка.

При сравнении используется eql, которая не умеет сравнивать списки.

Для работы с множествами есть стандартные функции: объединение, пересечения.

member --- позволяет проверить присутствие элемента в списке

`(member el lst)`

`(member '(a b) '(c (a b) d))`

Если el --- атом, то все найдется.

Если подадим список, то система не обнаружит этот список, но можно повлиять на
работу функции member.

При создании функции используется система ключевых параметров, они могут
быть использованы. Реализация функции с переменным числом параматров
создается с помощью ключевых параметров. Надо знать имена.

Ключевой параметр test.

`(member '(a b) '(c (a b) d) :test #'equal)`

На выходе:

`((a b) d)`

Функционал --- принимает в качестве аргументов функции, или возвращает функцию.

1. Применяющие (apply, funcall)
2. Отображающие (mapcar, maplist)

mapcar принимает первым параметром имя функции или lambda-опеделение. Применяет
функцию к элементам, проходя только по верхнему уровню.

Может применять и многоаргументную функцию:

`(mapcar #'fun lst1 lst2 ... lstk)`

Если меньше mapcar не работает, если больше, то последние игнорирует.

Выбирает головы списков, применяет, потом головы хвостов, применяет и т.~д.

Получает несколько результатов, возвращет список результатов.

maplist должна уметь работать с список, с хвостом списка, который список...

Может быть одно и многоаргументной.

`(maplist #'fun lst1 lst2 ... lstk)`

Списки целиком, потом хвосты, потом хвосты хвостой и т.~д.

Заканчивает работу, когда заканчивается самый короткий.

mapcar и maplist имеют аналоги, которые не создают копий, используют
структуро-разрушающую функцию nconc:

`mapcan`
`mapcon`

`(find-if #'pred lst)`

Функция find-if проходит по верхнему уровню, возвр певрый элемент списка,
удовлетворяющий данному предикату.

`(find-if #'odd (2 4 7 5))` -> 7

Не удовлетворяющий:

`(find-if-not #'pred lst` -> 2
`(find-if-not #'add (2 4 7 5))` -> 2

Удаление по условию:

`(remove-if #'pred lst)`
`(remove-if-not #'pred lst)`

Применение функции касадно.

`(reduce #'fun lst)`

Для первых двух, потом для результату и след элементу, к рез-ту и элементу и
тд.

`(every #'predicate lst')`

возращает T, если все удовлетворяют предикату.

`(some #'predicate lst)`

Примеры:

```
(defun consist-of (lst)
    (if (member (car lst) (cdr lst)) 1 0))
```

```
(defun all-last-element (lst)
    (if (eql (consist-of lst) 0) (list (car lst)) ())
```

```
(defun collection-to-set (lst)
    (mapcon #'all-last-element lst))
```

```
(collection-to-set '(i t i g t k s i f k)')
```

Результат: `(g t s i f k)`

```
(defun decart (lstX lstY)
    (mapcan #'(lambda (x)
                    (mapcar #'(lambda (y)
                                    (list x y)) lstY))
                                                lstX))
```

`(decart '(a b) '(1 2))` -> ((a 1) (a 2) (b 1) (b 2))

## Рекурсия

Рекурсия --- ссылка на описываемый объект внутри описания этого объекта.

Закончить надо, когда закончится список. Не единственная причина выхода из
рекурсии.

Надо менять аргументы.

Думать, как первый раз запустить.

Классификация рекурсий:

1. Простая рекурсия: рекурсивный вызов встречается в теле функции один раз.
2. Рекурсия первого порядка: рекурсивный вызов несколько раз.
3. Взаимная рекурсия: несколько рекурсивных функций, которые вызывают друг
   друга.

Проверить не нужно ли выйти из рекурсии, а потом вызов.

Первые ветки --- выход.

Собирать все на выходе --- неэффективно.

Надо не оставлять отложенных вычислений.

Если все сделать заранее, то все будет классно :).

В стеке ничего не надо хранить, он не переполнится --> хвостовая рекурсия.

Надо, чтобы не оставалось недоделаннной работы.

Примеры:

```
(defun my_member (el lst)
    (cond ((null lst) Nil)
          ((equal el (car lst)) T)
          (T (my_member el (cdr lst)))))

(my_member 'a '(a b c)) ; -> T

(my_member Nil ()) ; -> Nil (не совсем правильно,
                   ; можно переставить два условия выхода)
```

Неэффективный способ:

```
(defun my-reverse (lst)
    (cond ((null lst) lst)
          (T (append (my-reverse (cdr lst) (cons (car lst) lst))))))
```

Нехвостовая в хвостовую, используя доп параметр.

Ещё способ:

```
(defun my-reverse1 (lst)
    (move-t lst ()))

(defun move-to (lst result)
    (cond ((null lst) result)
          (T (move-to (cdr lst) (cons (car lst) result)))))
```

# Лекция 5

> 16.03.2022

5-ая --- любые стандартные функции (допускается неэффективность).

6-7 --- улучшение.

Рекурсивная функция --- функция, вызывающая сама себя.

Хвостовая рекусия может останавливать работу:

1. по одному условию;
2. по нескольким условиям.

Хорошая рекурсия --- это когда формируем результат на входе, не остается
недовычисленных результатов.

```lisp
(defun fun (x)
    (cond (end_test end_value)
          (t (fun chanched_x))))
```

Первый атом:

```
(defun first_a (lst)
    (cond ((atom lst) lst)
          (t (first_a (car lst))))
```

Первое нечетное:

```
(defun find_first_odd (lst)
    (cond ((null lst) nil)
          ((odd (find_a lst)) (first_a lst))
          (t (find_first_odd (cdr lst)))))
```

```
(defun my_nth (lst n)
    (cond ((null lst) nil)
          ((= n 0) (car lst))
          (t (my_nth (cdr lst) (- n 1)))))
```

Дополняемая рекурсия (есть доп функция, которая используется доп метод
обработки рекурсивного вызова).

```
(defun fun (x)
    (cond (end_test end_value)
          (t (add_function add_value
                           (func changed_x)))))
```

```
(defun my_length (lst)
    (cond ((null lst) 0)
          (t (+ 1 (my_length (cdr lst))))))
```

Преобразование многоуровневого списка в одноуровневый:

```
(defun into-one-level (lst)
    (cond ((null lst) nil)
          ((atom lst) (cons lst))
          (t (append (into-one-level (car lst)
                      into-one-level (cdr lst))))))
```

Если в качестве дополнительной функции используется cons, то это
cons-дополняемая рекурсия.

```
(defun insert_help (x lst)
    (cond ((null lst) (list x))
          ((<= x (cdr lst)) (cons x lst))
          (t (cons (car lst) (insert_help x (cdr lst))))))
```

```
(defun sort_help (lst1 lst2)
    (cond ((null lst1) lst2)
          (t (sort_help (cdr lst) (insert_help (car lst1) lst2)))))
```

```
(defun sort_ins (lst)
    (sort_help lst ()))
```

# Лекция 7 

> 30.03.2022

## Prolog

Работает со знаниями, не с данными.

Мат логика:

* высказываения;
* операции (конъюнкция, дизъюнкция, отрицание);
* предикаты.

Логическое программирование:

* символьная обработка, не числовая;
* работа со знаниями.

Аксиома -- факт (то, что принимается как справедливое утверждение).

Теоремы -- это, в общем, знания.

Появилось в 70-е годы.

Программа на пролог -- база знаний, состоящая из фактов (аксиом) и ...
(что-то про опрации).

Вопросы???

База данных сост из предложений, каждое из которых заканчивается точкой.
Начинается со слова clause (предложение)???

go -- цель

Терм -- либо константа, либо переменная, либо составное тело.

Надо синтаксически отличать переменные и константы:

`ab` -- символьный атом (константа???)
`Ab, _a` -- пременная

Использование переменных -- более высокий уровень абстракции.

Именованные переменные и анонимные.

Внешняя форма составного терма:

`f(t1, t2, ..., tn)`

f -- главный функтор (имя отношения);
t1, ..., tn -- термы.

Символьные атомы, как для объектов, так и для имен отношений.

`student(ivanov, mgtu).`

`student(ivanov).`

`student(X, mgtu).` -- в момент фиксации не имеет логического значения???
Задача системы "выполнить", определить истина или ложь.

1 и 2 -- разные знания.

Если в последнем точка, то система не знает, чему равно X.

Какой-то X может быть студентом.

Правило будет ли X студентом.

При формулировке X не имеет значения вообще.

Не содержат переменные -- основные, иначе -- неосновные.

`A := B1, B2, ..., Bk.`

`student(X, mgtu) := докум(X, att), выше(ball, 296)`

Особенный способ работы с переменными:

не задаем значение переменной, система сама подберет её значение, так, чтоб
выражение было истинно, это ее цель (подобрать такие значения, чтобы
ответ был "да").

Переменные нужны для передачи данных во времени и пространстве
(подпрограммы). 

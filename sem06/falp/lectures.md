# Лекция 4

> 09.03.2022

1. Стуктуроразрушающие
2. Неструктуроразрушающие (делают копии, работают медленнее)

Все работают только с верхним уровнем списка.

При сравнении используется eql, которая не умеет сравнивать списки.

Для работы с множествами есть стандартные функции: объединение, пересечения.

member --- позволяет проверить присутствие элемента в списке

`(member el lst)`

`(member '(a b) '(c (a b) d))`

Если el --- атом, то все найдется.

Если подадим список, то система не обнаружит этот список, но можно повлиять на
работу функции member.

При создании функции используется система ключевых параметров, они могут
быть использованы. Реализация функции с переменным числом параматров
создается с помощью ключевых параметров. Надо знать имена.

Ключевой параметр test.

`(member '(a b) '(c (a b) d) :test #'equal)`

На выходе:

`((a b) d)`

Функционал --- принимает в качестве аргументов функции, или возвращает функцию.

1. Применяющие (apply, funcall)
2. Отображающие (mapcar, maplist)

mapcar принимает первым параметром имя функции или lambda-опеделение. Применяет
функцию к элементам, проходя только по верхнему уровню.

Может применять и многоаргументную функцию:

`(mapcar #'fun lst1 lst2 ... lstk)`

Если меньше mapcar не работает, если больше, то последние игнорирует.

Выбирает головы списков, применяет, потом головы хвостов, применяет и т.~д.

Получает несколько результатов, возвращет список результатов.

maplist должна уметь работать с список, с хвостом списка, который список...

Может быть одно и многоаргументной.

`(maplist #'fun lst1 lst2 ... lstk)`

Списки целиком, потом хвосты, потом хвосты хвостой и т.~д.

Заканчивает работу, когда заканчивается самый короткий.

mapcar и maplist имеют аналоги, которые не создают копий, используют
структуро-разрушающую функцию nconc:

`mapcan`
`mapcon`

`(find-if #'pred lst)`

Функция find-if проходит по верхнему уровню, возвр певрый элемент списка,
удовлетворяющий данному предикату.

`(find-if #'odd (2 4 7 5))` -> 7

Не удовлетворяющий:

`(find-if-not #'pred lst` -> 2
`(find-if-not #'add (2 4 7 5))` -> 2

Удаление по условию:

`(remove-if #'pred lst)`
`(remove-if-not #'pred lst)`

Применение функции касадно.

`(reduce #'fun lst)`

Для первых двух, потом для результату и след элементу, к рез-ту и элементу и
тд.

`(every #'predicate lst')`

возращает T, если все удовлетворяют предикату.

`(some #'predicate lst)`

Примеры:

```
(defun consist-of (lst)
    (if (member (car lst) (cdr lst)) 1 0))
```

```
(defun all-last-element (lst)
    (if (eql (consist-of lst) 0) (list (car lst)) ())
```

```
(defun collection-to-set (lst)
    (mapcon #'all-last-element lst))
```

```
(collection-to-set '(i t i g t k s i f k)')
```

Результат: `(g t s i f k)`

```
(defun decart (lstX lstY)
    (mapcan #'(lambda (x)
                    (mapcar #'(lambda (y)
                                    (list x y)) lstY))
                                                lstX))
```

`(decart '(a b) '(1 2))` -> ((a 1) (a 2) (b 1) (b 2))

## Рекурсия

Рекурсия --- ссылка на описываемый объект внутри описания этого объекта.

Закончить надо, когда закончится список. Не единственная причина выхода из
рекурсии.

Надо менять аргументы.

Думать, как первый раз запустить.

Классификация рекурсий:

1. Простая рекурсия: рекурсивный вызов встречается в теле функции один раз.
2. Рекурсия первого порядка: рекурсивный вызов несколько раз.
3. Взаимная рекурсия: несколько рекурсивных функций, которые вызывают друг
   друга.

Проверить не нужно ли выйти из рекурсии, а потом вызов.

Первые ветки --- выход.

Собирать все на выходе --- неэффективно.

Надо не оставлять отложенных вычислений.

Если все сделать заранее, то все будет классно :).

В стеке ничего не надо хранить, он не переполнится --> хвостовая рекурсия.

Надо, чтобы не оставалось недоделаннной работы.

Примеры:

```
(defun my_member (el lst)
    (cond ((null lst) Nil)
          ((equal el (car lst)) T)
          (T (my_member el (cdr lst)))))

(my_member 'a '(a b c)) ; -> T

(my_member Nil ()) ; -> Nil (не совсем правильно,
                   ; можно переставить два условия выхода)
```

Неэффективный способ:

```
(defun my-reverse (lst)
    (cond ((null lst) lst)
          (T (append (my-reverse (cdr lst) (cons (car lst) lst))))))
```

Нехвостовая в хвостовую, используя доп параметр.

Ещё способ:

```
(defun my-reverse1 (lst)
    (move-t lst ()))

(defun move-to (lst result)
    (cond ((null lst) result)
          (T (move-to (cdr lst) (cons (car lst) result)))))
```

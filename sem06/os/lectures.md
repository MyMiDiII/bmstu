# Лекция 2

монтирование --- это система действий, в результате которой файловая система
становится доступной.

Для монтирования ФС требуются права привилегированного пользователя.

Используется команда mount.

`mount ключи -t тип_файловой_системы -o опции_файловой_системы устройство
каталог_назначения`

Отмонтирование:

`umount ключи -t тип_файл_сист -o опции_ф_с`

Кроме основной команды есть две команды: там могут указываться имя ФС.

`mount.nfs`

Есть разные версии.

Винда:

`mount.ntfs`

Наиболее часто:

* имя устройства или другого ресурса, который содержит монтируемую ФС;
* точка монтирования --- каталог, к которому подмонтируется ФС; должна
  существовать, иначе ошибка.

Когда ФС смонтирована в существ. дир., все файлы и поддир. этой
смонтированной системы становятся файлами и поддир точки монтирования.

Если дир. тм содержала к-л. файлы и поддир, то они не теряются, а становятся
невидимыми.

Иногда может оказаться нужным явно указывать при монтировании тип ФС (опция
-t).

Например, если осуществляетя попытка подмонтированить новую ФС, имеющую
новый тип, но поскольку U/L могут поддерживать большое количество
ФС (они могут поддерживать ФС разных типов), ... структуру ФС.

Рассмотрим пример.

```bash
# mount /dev/sda1 /mnt
```

Пытается монтированть устройство /dev/sda1 с файловой системой ext3 в каталог
mnt с режимом только чтение.

Если нет библиотек для поддержки той или иной ФС, или система не является ext3,
будет выведено сообщение о невозможности монтирования.

Если необходимо включить режим только записи:

```bash
# mount -o rw /dev/sda1 /mnt
```

Структура superblock предназначена для описания подмонтированных ФС.

Она содержит всю необходимую инф-цию для обращения к файлам конкретной ФС.

struct inode --- дескриптор физ. файла.

struct dentry --- описывает элемент каталога (доступ к файлам).

struct file --- описывает открытый файл (открыт к-л процессом).

Для системы существуют только процессы, их она обслуживает, ими она
управляет.

Команды, которые мы пишем в ком строке --- коды системы, которые ей
выполняются.

**ЗДЕСЬ ДОЛЖНА БЫТЬ ФОТКА. ТАК ВАНЯ СКАЗАЛ.**

Кеши по своему назначению хранят данные, к которым били последние
обращения, по принципу lru, по принципу наибольшей вероятности обращений.

Для деятельности человека хар-но, что он обращался к данным, то в след
момент, он будет обращаться к этим же данным.

Системная таблица открытых файлов. В этой таблице --- десрипторы всех
открытых в системе файлов, если файл открыт несколько раз, то будет
существовать соотв. кол-во дескрипторов файлов.

Т. к. дескрипторы --- структура для обслуживания
...............................................................................
.................................................

Одно имя --- для системы это хардлинк.

## СуперБлок

Раздел жесткого диска (всторичной памяти) с ФС ext2.

Блок -- минимально адресуемая единица физ. носителя (вторичной памяти).

ФС предназначена для долговременного хранения и доступа к файлам. Без доступа
никому не нужно.

Доступ многоуровневый. Втор. память --- внешнее устройство.

Дисковые inode содержат информацию об адресах блоках втор. памяти, в которой
находится файл, кот. описывается конкретным inode-ом.

inode корневого каталога...

Суперблок хранит инфомацию об inod-ах, обеспечивает доступ к дисковому айноду,
а дисковый айнод хранит информацию об адресах.

**ЗДЕСЬ ДОЛЖНА БЫТЬ СУПЕРСХЕМА СУПЕРБЛОКА**

Суперблоки в системе объединены в списко. В системе столько действующих
суперблоков, соклько смонтированно ФС. Мб смонитрованно несколько ФС одного и
того же типа.

Доступ к файлам возможен только в смонтированной ФС, нужен соотв. суперблок.

```c
struct super_block
{
    struct list_head s_list;
    dev_t s_dev;
    unsigned long s_blocksize;
    struct file_system_type *s_type; \\ структура file_system_type предназначена для
                                     \\ регистрации типа конкретной ФС
    const struct super_operations *s_op;
    unsigned long s_flags;
    unsigned long s_magic;
    struct dentry *s_root;
    struct rw_semaphore s_umount;
    struct list_head s_mount;
    struct block_device *s_bder;
    ...
    struct list_head s_inodes_wb;
}
```
Грязный файл --- измененное значение.
**PHOTO AGAIN**

# Лекция 4

> 02.04.2022

```
struct inode_operations
{
    ...
    int (*create)(struct inode *, struct dentry *, umode_t, bool);
    ...
    int (*mkdir)(struct inode *, struct dentry *, umode_t)
    int (*rmdir)(struct inode *, struct dentry *);
    int (*mknod)(struct inode *, struct dentry *, umode_t, dev_t);
    int (*rename)(struct inode *, struct dentry *, struct inode *, struct
dentry *);
    ...
    int (*atomic_open)(struct inode *, struct dentry *, struct file *,
unsigned open_flag, umode_t create_mode, int onened);
}
```

Поиск указанного индекса в указанном каталоге

permition -- проверяет права доступа к указанному файлу, на который ссылается
inode.

Если доступ разрешен, то функция возвращает 0, иначе -1.

Для большинства файловых систем устанавливается в Null, и в этом случае
используется метод, определенные в ВФС.

Сравнение битовых полей режима доступа с указанной маской.

link -- жесткая
softlink -- гибкая ссылка

create вызывается open (open(2) и create(2)), то есть create вызывается этими
двумя системными вызовами, только в случае, если вы вызывается open и create
для обычного файла, при этом создается новый inode с указанным режимом доступа
mode и этой inode связан с элементом пути, то есть dentry. Про параметр bool
истрия умалчивает.

mkdir -- создаем директорию

mknod -- можно создать именованный канал, файл устройства или сокета.

Информация о созданном устройстве будет хранится в параметре dev_t.

atomic_open вызывается из open, при этом файл или создается, или открывается
одной неделимой операцией.

> Важно! Эти функции перечислены в `struct inode_operations`

```
struct inode
{
    const struct inode_operations *i_op;
    ...
}
```

Обращение к функции operations

```
inode->i_op->permission(...);
```

Для доступа к файлу необходимо получить его inode, тк индекс inode --
идентификатор.

При этом необходимо понимать, что для доступа к файлу имя файла
необязательно знать, обязательно номер inode, а имя можно не знать.

<!-- <img src="./img/lec04_01.jpg" alt="drawing" width="200"/> -->

<p align="center">
  <img width="300" src="./img/lec04_01.jpg">
</p>

## Как выполняется доступ к файлу?


/usr/ast/index

Начинаем с содержимого корневого каталога.

<!-- <img src="./img/lec04_02.jpg" alt="drawing" width="600" align="center"/> -->

<p align="center">
  <img width="600" src="./img/lec04_02.jpg">
</p>

Дескриптор файла с определенными значениями полей. На дисковом inode
указываются адреса блоков, ...

Мы из inode с номером 6 определили, что нужная нам информация о директории
usr находится в блоке 132.  Это usr директория.

Говорят, что `/usr/ast` находится в блоке 406.

406 -- содержимое `/usr/ast`. 26 текущая, 6 родительская `/usr`

В системе есть inode дисковый (обязательно содержит информацию об адресах
блоков конкретного файла)

Копия индекса, которая находится в памяти, содержит поля, которых нет в
дисковом индексе:

1. В inode ядра (копия дискового, может не быть дискового, если это
   вирутальная ФС, которая не связана ни с каким внешним запоминающим
устройством).

1. Поля ответсвенные за блокировки
2. Логический номер устройства
3. Номер индекса -- поле `unsigned  long i_ino`, в дисковом индексе это поле
   не нужно, так как на диске индексы хранятся в линейном массиве и ядро
идентифицирует индекс по его смещению.
4. Ссылки на другие индексы, для организации в ядре хэш-очереди, кроме того ядро
   ведет список свободных индексов.
5. Счетчик ссылок на файл, в котором содержится число, указывающее,
   сколько раз был открыт этот файл.

Файл -- поименнованная совокупность данных, но когда процесс желает с ней
работать, для системы это будет открытый файл.

Для этого дополнительно сущесвтует структура struct file.

## Объект dentry

Роберт Лав. Операционная система Linux.

ВФС считает каждый каталог файлом, который содержит список других каталогов и
файлов.

Для работы с ... существует структура `struct dentry`.

При этом ядро создает объект dentry для каждого компонента пути, причем
такой объект создается "налету", когда процесс обращается к файлу.

Объект `detnry` связывает компонент пути с соотв индексом, или соотв inode-ом.

При поиске питу `/tmp/test` ядро создаст объект `dentry` для корневого
каталога, затем создаст объекст dentry для tmp и третий объъект dentry для
test.

У объекта dentry нет соотв отображения на диске.

# Лекция 5

> 16.04.2022

Один и тот же inode может иметь несколько ссылок, то поле `i_dentr` должно
представлять связный список.

Двухсвязный список ... и непритиворечивых ..

То есть там находятся объекты dentry к которым были последние обращения.

Добавление в этот двухсвязный список объекта dentry должно выполняться по
значению времени.

Новый объект dentry записывается в хвост, удаление с головы.

Каждый элемент таблицы dentry_hashtable (массива) является указателем на список
тех объектов dentry, которые соответсвуют какому-то ключу. Значение ключа
определяется функцией d_hash(), что позволяет для каждой файловой системы
реализовать свою hash-фунцкию. Поиск в хэш-таблице осуществляется функцией
d_lookup().

Приведенный пример показывает, что сначала идет поиск denty в кэше, если поиск
приводит к тому, что какого-то элемента каталога нет в кэше, то происходит
обращение таким образом каким-рассмотрели. Найденный объект dentry, его inode
будет помещен в кэш.

пропущено + фото

inode cache

В linux inode_cache -- в файле `fs/inode.c`

inode_cache представляет из себя глобальный cache-массив inode_hashtable, в
котором каждый inode хэшируется по значению указателя на суперблок. И номеру
inode-а. В случае отсутствия суперблока `inode->i_db == NULL` вместо хеш-массива
inode добавляется к двухсвязному списку `anon_hash_chain`. Примерами таких
анонимных inode-ов служат сокеты, которые создаются `sock_allock() //
(net/socket.c)`, которая вызывает функцию `get_empty_inode // (fs/inode.c)`

2.  inode_in_use содержит inode-ы, у которых i_count > 0 и i_nlink > 0.
inode-ы, которые создаются с помощью вызова функции get_empty_inode() и
get_new_inode() добавляются в этот inode.

3. inode_unused, для которых i_count = 0.

4. Также для каждого суперблока свой... продолжение письм.

struct file -- описывает открытые файлы.

Предоставляет информацию о файлах, кот были открыты процессами.

Это одна единственная таблица, недоступная пользователю.

Важнейшим моментом объяснения ситуации с открытыми файлами являетс процесс
открытия файла.

В различных структурах даже ядра имеются функции open.

# Лекция

Специальные файловые устройста обеспечивают доступ к периферийным устройствам.

Эти файлы обеспечивают связь ФС и драйверов устройств.

Такая интерпретация Спец Файл Устр обеспечивает доступ к фаловым
устройствам, как к обычным файлам.

Так же как и файл СФУ может быть открыт, закрыт, в него можно писать,
читать.

Каждому внешнему устройству UNIX и LINUX ставит в соответсвие один
специальный файл.

Обычно эти файлы можно увидеть в каталоге /dev в корневой файловой системе.

Подкаталог /dev/fd содержит файлы в именами 0, 1, 2, но в некоторых системах
имеются файлы с именами /dev/stdin, /dev/stdout, /dev/stderr.

Система поддерживает два типа СФУ:

1. Символьный (небуфферизуемый, nonbuffered)
2. Блочный (буфферизуемый)

В UNIX/LINUX связь ... с СФУ обеспечивает ... или индексный
файловый дескриптор.

Взаимодействие программ с аппаратной частью под управление UNIX/LINUX
осуществляется по след схеме:

**фото**


Часть кода ядра, которая предназначена для управления конктретным устройством.

Драйверы в любой системе пишутся по правилам этой системы, на основании структур
ядра определенныых в системе.

Такие структуры определяют точки входа.

Драйвер -- код, написанный по строгим правилам системы.

Задача драйвера -- управлять внешним устройством.

То есть драйвер должен преобразовывать данный поступающие/получаемые от
устройства.

В формате данных, определенном на устройстве.

Формат данных, полученный от устройства должен быть преобразован в формат
понятный приложения.

Только разработчик устройства знает все передаваемые форматы.

Три типа драйверов:

1. Выполнение которых инициализируется при запуске системы. VGA котроллер.
Котроллеры IDE. Материнская плата, последовательные и параллельные порты.

2. Реализованные, как загружаемые модули ядра. HID -- драйвера устройств
   взаимодействия с пользователем.
Нужно выгрузить старый, только потом установить новый. ЗМЯ используются
SCASE, звуковые сетевые карты.
Файлы модулей ядра в подкаталогах каталога /???/modules. Обычно при
инталяции системы устанавливается перечень модулей, которые будут
автоматически загружаться при запуске системы. /etc/modules хранит
список. ... Для этого существуют специальные скрипты типа update modules. 

3. Драйвера модемов. Для идентификации СФУ старший (основной) и младший
   (дополнительный) номера устройств.

Обсуждение на основе символьных устройств.

Старший и младший номера устройств идентифицирует драйвер, с которым
связано устройство. ... А виртуальные консоли и последовательные терминалы
управляются драйвером 4.

... используются ядром для определения конкретного устройства.

## Внутреннее представление номеров устройств

В ядре существует тип div\_t

Стандарт POSIX.???, но не оговаривает формат полей.

Начиная с версии ядра 2.6.0 dev_t -- это 32-х разрядное число, где 12 для
старшего номера и 20 для младшего.

Все это важно при написании собвственного драйвера устройств. Код драйвера
никак не должен интерпретировать эти значения, он должен их просто
успользовать. Надо использовать набор макросов из linux/kdev.h. Эти
макросы позволяют получить старший и младший номера устройств.

Выделение и высвобождение номеров устройств.

**фото**

Причем часть miner часто устанавливается равной 0.

count -- число номеров устройств, которые запрашиваются. Если больше, ..., но
все будет продолжать работать, если будет досупен диапазон устройств. Правило
возвращения аналогична другим функциям ядра.

Данная фукнция хорошо работает, если заранее известно конкретное устройство,
которому нужен номер, однако часто не извесно, какой старший номер
использует ваше устройство, поэтому разработчики ядра особо
подчеркивают, что для динамического выделения старшего номера нужно
использовать функцию alloc\_chrdev\_region.

**фото**

В этой фукнции параметр dev только выходной. И он будет содержать номер... при
успешном завершении функции.

first_miner -- первый запрошенный младший номер, обычно равен нулю, остальное
аналогично.

## Динамическое выделение старшего номера

.. старшие номера статически назначаются большинству устройств.

С помощью команды **фото** список символьных устройств системы.

Ориентируясь на выделенные в системе старшие номер можно выделить. Кроме того
могут быть назначены случайные статические номера, но при этом следует
помнить, что новые номера не присваиваются, в результате разработчик драйвера
должен сделать выбор:

* можно выбрать номер, который кажется неиспользуемым
* выделять номера динамически.

..., как только ваш драйвер получит более широкое распространение, случайно
выбранный старший номер скорее всего приведет к конфликтам и
неисправностям. Таким образом, разработчики ядра рекомендуют использовать
динамическое получение номеров устройств, то есть не следует брать случайным
образом номер из тех, которые в текущий момент кажутся свободными.

Но у динамического выделения номеров имеется недостаток: нельзя заранее создать
узлы устройства, так как главный номер будет получен впоследствии, то есть он
неизвестен.

Очевидно, что существуют рекомендации, одной из который является следующее:

* при загрузке драйвера с динамическим назначением старшего номера ...
  следует заменить соответствующим скриптом, который после вызова.
* рекомендуется в скрипте использовать инструмент типа awk, читает
  документ по строкам и выполняет указанные разработчиком действия и результат
выводит на тотальный вывод. 

Direct memory access освобождение процессора от рутинной перекачки в оперативную
память.

В этом случае нет предварительно выделять буфер dma и установка поля mapping
используется для устойчивого опредtления многократно используемых буферов.

Поле devt для создания в sys/fs девайса.

поле u32 id -- экземпляр устройства.

Указатель на struct device driver -- это основная структура, описывающая
драйвер, в системе имеются структуры, предназанчения для описания
устройств...
